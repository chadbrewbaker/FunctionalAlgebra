\documentclass{beamer}

% \usepackage{beamerthemesplit} // Activate for custom appearance

\usepackage{listings}
\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small}}{}
\lstnewenvironment{ccode}{\lstset{language=C,basicstyle=\small}}{}

\title{Programming with Jr. High Algebra}
\author{Chad Brewbaker}
\date{May 5, 2016}

\begin{document}

\frame{\titlepage}

%\section[Outline]{}
%\frame{\tableofcontents}

%

\begin{frame}[fragile]
How can we get programming in the Jr. High curriculum?\newline
\newline
What language did we use before COBOL and ALGOL?\newline
\newline
How can we refactor on a napkin without an IDE?\newline
\newline
How can we prove our code is correct?

\end{frame}


\begin{frame}[fragile]
How can we easily get programming in the Jr. High curriculum?\newline
(Algebra)\newline
What language did we use before COBOL and ALGOL?\newline
(Algebra)\newline
How can we refactor on a napkin without an IDE?\newline
(Algebra)\newline
How can we prove our code is correct?\newline
(Algebra)
\end{frame}


\begin{frame}[fragile]
1) Ignore fancy terminology.\newline\newline
2) Use sums, products, and exponents.\newline\newline
3) Teach Jr. High Algebra instructors just enough Haskell.  
\end{frame}


\begin{frame}[fragile]
The Haskell language\newline\newline
Advised by Simon Peyton Jones of Microsoft Research.\newline\newline
Looks like Algebra. \newline\newline
Easy to test. No rando database calls in a function without IO warning.
\end{frame}


\begin{frame}[fragile]
Function notation: Algebra, Haskell, C\#\newline\newline

$f(\mathbb{Z},\mathbb{Z}) \rightarrow$ String
\begin{code} 
f :: (Int, Int) -> String
\end{code}
\begin{ccode} 
String f(int a, int b); 
\end{ccode}
\end{frame}


\begin{frame}[fragile]
Sum: $A$ or $B$\newline\newline
$$A + B $$
\begin{code} 
data X = A | B
f :: X -> Either A B
\end{code}

\begin{ccode} 
enum X { A, B }; //C
\end{ccode}

Sally's drink is either Coffee or Tea.
\begin{code}
type Drink = Coffee | Tea
\end{code}


\end{frame}


\begin{frame}[fragile]
Product: $A$ and $B$\newline\newline
$$A \times B$$
\begin{code}
type X = (A,B)
\end{code}

\begin{ccode}
struct X{ A a; B b;}; //C
\end{ccode}

Sally's dinner consists of a fruit and a vegetable.
\begin{code}
type Dinner =  (Fruit, Vegetable)
\end{code}
\end{frame}


\begin{frame}[fragile]
Exponential: From A to B\newline\newline
$$ B^{A} $$
$A$ is called the domain or input type. $B$ is called co-domain or return type.
\begin{code}
f :: A -> B
\end{code}

\begin{ccode}
B f( A  a); //C
\end{ccode}

Sally chops a carrot.
\begin{code}
chop :: Carrot -> DicedCarrot
\end{code}

\end{frame}

\begin{frame}[fragile]
Exponential: $B^{A} $\newline\newline

Example from JEG's RailsConf2016 talk
\begin{ccode}
Integer fib(Integer a){
    if (a == 0 || a == 1) 
        return 1;
   return fib(a-1) + fib(a-2);
}
\end{ccode}

What is the runtime of fib(n)?
\end{frame}


\begin{frame}[fragile]
Exponential: $ B^{A} $\newline\newline

Focus on this line
\begin{ccode}
      return fib(a-1) + fib(a-2);
\end{ccode}

How many branches? Bool\newline
How deep is each branch? $\approx A$ 
\begin{code}
fibExecutionUnit :: A -> Bool
\end{code}
         $$O(2^{A})$$
\end{frame}





\begin{frame}[fragile]
Terminology for simple values.\newline\newline
$\sqrt{-1}$ Undefined 
\begin{ccode}
0 Void
1 Unit
2 Bool 
3 Tri
4 Quad
\end{ccode}
\end{frame}



\begin{frame}[fragile]
Constants are functions with the Unit as an argument.
$$a = a^{1} $$
\begin{code}
f ::  A
f' :: () -> A
\end{code}
\end{frame}


\begin{frame}[fragile]
Tuples vs tuple lookups\\
$$a \times a = a^2$$


\begin{code}
f :: (A,A)
f':: Bool -> A  -- Choose the left or right A
\end{code}

\end{frame}


%\begin{frame}[fragile]
%\begin{ccode}
%Int  ifThenElse(int x){
%if( x)
%   return 3;
%else
%   return 4;
%}
%\end{ccode}
%If statements are an inlined boolean function
%\begin{code}
%f :: Bool -> a
%f x = if x then 3 else 4
%\end{code}

%$(a)^2 = (a,a)$

%\end{frame}

% log  p->a  = p
%colog p->a = a


%\begin{frame}[fragile]
%Switch statements are???
%\end{frame}


\begin{frame}[fragile]
Void behaves like zero
$$1= a^{0}$$
\begin{code}
f :: Unit
f':: Void -> A
\end{code}
$$a\times0 = 0$$
\begin{code}
g :: (A,Void)
g':: Void
\end{code}
$$a+0 = a$$
\begin{code}
h :: A | Void
h':: A
\end{code}
\end{frame}


\begin{frame}[fragile]
Derivative(N) is removing one element from N
$$ {d \over dx}(ax^{n}) = a \times n \times x^{n-1}$$
\begin{code}
data N = M | 1
f ::  (a, N -> x)
f' :: (a, N, M -> X)
\end{code}
($a$, which element we took out of N, the new function)
\end{frame}

\begin{frame}[fragile]
Curry. We can pass argument lists or chain functions.
$$ (a^{m})^{n} = a^{mn}$$

\begin{code}
curry :: n -> (m -> a)
curry' :: (n,m) -> a
\end{code}
\end{frame}

\begin{frame}[fragile]
Co-curry. Multiple function calls or return a tuple.
$$ a^{m}b^{m} = (ab)^{m}$$

\begin{code}
f :: (m -> a, m -> b)
f' :: m -> (a,b)
\end{code}
\end{frame}

\begin{frame}[fragile]
Splitting function inputs
$$a^{m}a^{n} = a^{m+n}$$
\begin{code}
data B = M | N
f :: (M -> a, N -> a)
f' :: B -> a
\end{code}
\end{frame}

\begin{frame}[fragile]
Ignoring some input or shrinking function input 
$$ a^{m} \div a^{n} = a^{m-n}$$
\begin{code}
data M = B | N
f :: (M -> a) remove (N -> a)
f' :: B -> a
\end{code}
\end{frame}

\begin{frame}[fragile]
Suppressing some outputs or shrinking the output type
$$ a^{m} \div b^{m} = ({a \over b})^{m}$$
\begin{code}
data A = N | B
f :: (m -> A) remove (m -> B)
f':: m -> N
\end{code}
\end{frame}


\begin{frame}[fragile]
Fermat's Little Theorem\\
$ a^{n} - a$ is divisible by $n$ when $n$ is prime.
$$ a^{n} - a = n\times k$$
$$ a^{n} = n\times k + a$$
\begin{code}
f :: N -> A
f':: (N, K) | A
\end{code}
This refactoring exists whenever $N$ is a prime size set.
\end{frame}

\begin{frame}[fragile]
Fermat's Last Theorem\\

$ x^{n} + y^{n} = z^{n} $ has no solutions for $n>2$.\newline

\begin{code}
f :: (N -> X) | (N -> Y)
f':: (N ->Z)
\end{code}
This refactoring never exists when $N$ is greater than size two.
\end{frame}


\begin{frame}[fragile]
Binomial Theorem.  \\ Refactor between product of sums and sum of products.
$$(a+b)^{n} = \sum_{k=0}^{n}{n \choose k} a^{n-k}b^{k}$$

$$(a+b)^{2} = a^{2} + 2ab + b^{2}$$
\begin{code}
f :: Bool -> (A | B)
f' :: Bool -> A
      | (Bool, A, B)
      | Bool -> B 
f'':: (A,A) | ((A,B) | (B,A)) | (B,B)
 
      
\end{code}
\end{frame}

\begin{frame}[fragile]
Binomial Theorem\\
$(a+b)^{3} = a^{3} + 3a^{2}b + 3ab^{2} + b^{3}$

\begin{code}
f :: Tri -> (A | B)
f' ::  Tri -> A  
       | (Tri, Bool -> A, B)  
       | (Tri, A, Bool -> B)
       | Tri -> B
f'' :: (A,A,A) 
       | ( (A,A,B) | (A,B,A) | (B,A,A) )
       | ( (A,B,B) | (A,B,B) | (B,A,B) )
       | (B,B,B)
\end{code}

\end{frame}

\begin{frame}
Binary tree.\newline\newline
Empty tree or a parent node and two children. \newline\newline
Tree  A = EmptyTree + (Parent A ,Left A, Right  A)\newline\newline
$T_{a} = 1+a{T_{a}}^{2} $\newline\newline
$a{T_{a}}^{2 } - T_{a}+ 1  = 0$\newline\newline
Solve with quadratic formula.\newline\newline
%$T_{a} = {1 - \sqrt {1 - 4a} \over 2a}$\newline
\end{frame}

\begin{frame}[fragile]
What the heck do we do with this? %\newline\newline
$$T_{a} = {1 - \sqrt {1 - 4a} \over 2a}$$

Wolfram Alpha, "Series [ [1 - Sqrt[1-4a]] / [2a] ] at 0"
$$1+a+2a^{2}+5a^{3} + 14a^{4} + 132a^{6}...$$
\begin{code}
data SixTree A = (Void,Void -> a)  | (Unit,Unit -> A) 
   | (Quint, Tri -> A) | (Fourteen, Quad -> A)
   | (OneThrityTwo, Hex -> A) 
\end{code}
\end{frame}

\begin{frame}[fragile]
Tips on how to read Algebra as a programmer.
\end{frame}

\begin{frame}[fragile]
All the functions from $N$ to $N$.
$${N^{N}}$$
\end{frame}

\begin{frame}[fragile]
All reorderings of $N$.
$$n! = n*(n-1)*...*2*1$$
\end{frame}


\begin{frame}[fragile]
Let's ignore some stuff.
$${1\over x}$$
\end{frame}

\begin{frame}[fragile]
Let's remove one element from $x$ in $x \rightarrow y.$
$$f^{'}(x)$$
Let's remove two elements from $x$ in $x \rightarrow y.$
$$f^{''}(x)$$
\end{frame}



\begin{frame}[fragile]
Let's ignore reordering.
$${1\over n!}$$
\end{frame}


\begin{frame}[fragile]
I'm about to give a stream of things.
$$\sum$$
\end{frame}


\begin{frame}[fragile]
I've got an arbitrarily large tuple.
$$\prod$$
\end{frame}


\begin{frame}[fragile]
Monads are foreign because we aren't used to Algebra with towers of exponents. $m$ is usually a container or operating system call.\newline\newline
%bind $$(mb)^{ ((mb)^{a})^{ma}} $$
Sequentially compose two items in the $m$ context. Pipe the return of the first into the second.\newline
$(>>=) = {m_b}^{ {m_b}^{a}m_a} $\newline\newline
Sequentially compose two items in the $m$ context. Do not pipe the output of the first to the second.\newline
$(>>) = {m_b}^{m_b m_a}$\newline\newline
Put $a$ in the $m$ context.\newline
return $= {m_a}^{a}$\newline\newline
\end{frame}


\begin{frame}[fragile]
\begin{code}
import System.Environment as SE
import System.Process as SP

printPath = SE.getExecutablePath >>= print
sentence = "say Two plus one equals three"
twoPlusOne = SP.system sentence 
           >> print (2+1)

saywhat :: String -> String
saywhat x = "say " ++  x
sayit x = SP.system $ saywhat x

sayExePath = SE.getExecutablePath
            >>= \x -> sayit x
\end{code}


\end{frame}

\begin{frame}[fragile]
Can we automate how we write code?\newline
I give the compiler two data types A and B.\newline 
The compiler searches for functions from A to B that typecheck.\newline
I give the compiler unit test hints so it avoids silly code paths.\newline
The compiler gives me hints on where it is getting stuck.\newline\newline
This tool is the Microsoft LEAN project.
\end{frame}

\begin{frame}[fragile]
My take on the future of automated programming.\newline\newline
Jr. High Algebra is a good language. LEAN jumped the shark.\newline\newline
We have free symbolic Alegebra packages like SymPy.\newline\newline
Where SymPy fails we have Microsoft's Z3 solver.\newline\newline
10x humans ask questions and give advice. Calculations are for computers.\newline\newline
Stay tuned for talk later this month ``Z3 and me".
\end{frame}


%\frame
%{
 % \frametitle{Features of the Beamer Class}
%
 % \begin{itemize}
  %\item<1-> Normal LaTeX class.
  %\item<2-> Easy overlays.
  %\item<3-> No external programs needed.      
  %\end{itemize}
%}
%\end{document}




\frame
{
  \frametitle{Bibliography}
  Haskell Curry(1934), ``Functionality in Combinatory Logic"\newline\newline
  Eric G Wagner(1986), ``Categories, Data Types, and Imperative Languages"\newline\newline
  Douglas McIlroy(1998), ``Power Series, Power Serious"\newline\newline
  Chris Taylor(2013), ``The Algebra of Algebraic Data Types"
}
\end{document}

